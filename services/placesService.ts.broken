import {
  SearchArea,
  SearchFilters,
  AggregateResponse,
  InsightType,
  PlaceResult,
  PriceLevel,
  OperationalStatus,
  TechStack,
  FitAnalysis
} from '../types';
import { MOCK_ZIP_COORDS } from '../constants';
import { detectTechStack } from './techDetector';
import { detectChain } from './chainDetector';

// Use local proxy server to bypass CORS
const PROXY_BASE = 'http://localhost:3001/api';
const GOOGLE_MAPS_API_KEY = import.meta.env.VITE_GOOGLE_MAPS_API_KEY;

// --- AGENT CONFIGURATION & CONSTANTS ---

const AGENT_CONFIG = {
  maxPlacesForScan: 80,
  excludedPrimaryTypes: ['fast_food_restaurant'],
  minRatingForFit: 3.8,
  maxRatingForFit: 4.9, // Avoid "too perfect" 5.0s with low volume
  scoring: {
    independent: 20,
    idealPrice: 15, // $$ or $$$
    healthyRating: 10,
    strongReviews: 10, // High review count
    commissionBleed: 35, // Has 3P delivery but no 1P ordering
    noOrdering: 15, // Fallback if no 3P detected but still no 1P
    legacySite: 10,
    lowConfidencePenalty: -5 // Penalize low-confidence tech detections
  }
};

// --- SCORING ENGINE ---

const calculateFitScore = (
  place: Omit<PlaceResult, 'fit' | 'techStack'>,
  tech: TechStack,
  isIndie: boolean
): FitAnalysis => {
  let score = 0;
  const reasons: string[] = [];

  // 1. Independence (CRITICAL)
  if (isIndie) {
    score += AGENT_CONFIG.scoring.independent;
    reasons.push("Independent");
  } else {
    reasons.push("Chain (Low fit)");
    return { score: 0, reason: "Chain Restaurant", isIndependent: false };
  }

  // 2. Owner.com Exclusion (Kill switch)
  if (tech.onlineOrdering.some(o => o.toLowerCase().includes('owner.com'))) {
    return { score: 0, reason: "Already on Owner.com", isIndependent: isIndie };
  }

  // 3. Price Level ($$ or $$$)
  if (place.priceLevel === PriceLevel.MODERATE || place.priceLevel === PriceLevel.EXPENSIVE) {
    score += AGENT_CONFIG.scoring.idealPrice;
    reasons.push("Ideal Price ($$-$$$)");
  }

  // 4. Rating Health
  if (place.rating >= AGENT_CONFIG.minRatingForFit && place.rating <= AGENT_CONFIG.maxRatingForFit) {
    score += AGENT_CONFIG.scoring.healthyRating;
    reasons.push("Strong Rating");
  }

  // 5. Review Volume (traction indicator)
  if (place.userRatingCount >= 100) {
    score += AGENT_CONFIG.scoring.strongReviews;
    reasons.push("Strong Review Volume");
  }

  // 6. Tech Stack Gaps (THE BIG ONE)
  const hasDelivery = tech.delivery.length > 0;
  const hasFirstPartyOrdering = tech.hasFirstPartyOrdering;

  if (hasDelivery && !hasFirstPartyOrdering) {
    score += AGENT_CONFIG.scoring.commissionBleed;
    reasons.push("High Commission Bleed (3P Only)");
  } else if (!hasFirstPartyOrdering && tech.onlineOrdering.length === 0) {
    score += AGENT_CONFIG.scoring.noOrdering;
    reasons.push("No Online Ordering");
  }

  // 7. Legacy Infrastructure
  if (['WordPress', 'Wix', 'GoDaddy', 'Custom', 'Unknown'].includes(tech.websitePlatform)) {
    score += AGENT_CONFIG.scoring.legacySite;
    reasons.push("Legacy Website");
  }

  // 8. Tech Detection Confidence
  if (tech.confidence < 50) {
    score += AGENT_CONFIG.scoring.lowConfidencePenalty;
  }

  score = Math.max(0, Math.min(score, 100));

  // Format Reason String
  let reasonString = reasons.slice(0, 3).join(", ");
  if (reasons.length > 3) reasonString += ` +${reasons.length - 3} more`;

  return { score, reason: reasonString, isIndependent: isIndie };
};

// --- API HELPERS ---

const getCoordinates = async (zipCode: string): Promise<{ lat: number; lng: number }> => {
  if (MOCK_ZIP_COORDS[zipCode]) return MOCK_ZIP_COORDS[zipCode];

  if (!GOOGLE_MAPS_API_KEY) return MOCK_ZIP_COORDS['28202'];

  try {
    const res = await fetch(`${PROXY_BASE}/geocode?address=${encodeURIComponent(zipCode)}`);
    if (!res.ok) throw new Error(`Geocoding status: ${res.status}`);
    const data = await res.json();
    if (data.results?.[0]?.geometry?.location) {
      return data.results[0].geometry.location;
    }
  } catch (e) {
    console.warn("Geocoding error, using default center.", e);
  }
  return MOCK_ZIP_COORDS['28202'];
};

const fetchPlaceDetails = async (placeId: string): Promise<Omit<PlaceResult, 'techStack' | 'fit'> | null> => {
  if (!GOOGLE_MAPS_API_KEY) return null;
  try {
    const fieldMask = 'id,displayName,types,rating,userRatingCount,priceLevel,formattedAddress,location,websiteUri,nationalPhoneNumber,currentOpeningHours';

    const res = await fetch(`${PROXY_BASE}/places/${placeId}`, {
      headers: {
        'Content-Type': 'application/json',
        'X-Goog-FieldMask': fieldMask
      }
    });

    if (!res.ok) return null;
    const data = await res.json();

    return {
      placeId: data.id,
      name: data.displayName?.text || 'Unknown',
      types: data.types || [],
      rating: data.rating || 0,
      userRatingCount: data.userRatingCount || 0,
      priceLevel: data.priceLevel as PriceLevel,
      address: data.formattedAddress || '',
      location: { lat: data.location?.latitude || 0, lng: data.location?.longitude || 0 },
      operationalStatus: OperationalStatus.OPERATIONAL,
      website: data.websiteUri,
      phone: data.nationalPhoneNumber
    };
  } catch (e) {
    console.error("Details fetch error", e);
    return null;
  }
};

// --- MOCK SERVICE (Fallback) ---

const runMockSearch = async (area: SearchArea, filters: SearchFilters, insightType: InsightType): Promise<AggregateResponse> => {
  await new Promise(resolve => setTimeout(resolve, 1000)); // Scan feel

  let baseCount = Math.floor(Math.random() * 150) + 40;
  baseCount = Math.floor(baseCount * (area.radiusKm / 2));
  if (filters.independentOnly) baseCount = Math.floor(baseCount * 0.65);

  const breakdown: Record<string, number> = {};
  const types = filters.includedTypes.length > 0 ? filters.includedTypes : ['restaurant'];
  types.forEach(t => { breakdown[t] = Math.floor(baseCount / types.length); });

  const places: PlaceResult[] = [];
  const baseLat = area.center?.lat || 35.2271;
  const baseLng = area.center?.lng || -80.8431;

  // Only generate detailed list if requested
  const generateCount = insightType === InsightType.PLACES ? Math.min(baseCount, AGENT_CONFIG.maxPlacesForScan) : 0;

  for (let i = 0; i < generateCount; i++) {
    const type = types[i % types.length] || 'restaurant';
    const rating = 3.5 + Math.random() * 1.5;
    const name = `Mock Restaurant ${i + 1}`;

    const chainResult = detectChain(name);
    const isIndie = !chainResult.isChain;

    // Mock chain exclusion
    if (filters.independentOnly && !isIndie) continue;

    const placeBase = {
      placeId: `mock-${i}`,
      name,
      types: [type],
      rating: parseFloat(rating.toFixed(1)),
      userRatingCount: Math.floor(Math.random() * 800),
      priceLevel: PriceLevel.MODERATE,
      address: '123 Mock St, Charlotte NC',
      location: { lat: baseLat + (Math.random() - 0.5) * 0.06, lng: baseLng + (Math.random() - 0.5) * 0.06 },
      operationalStatus: OperationalStatus.OPERATIONAL,
      website: 'http://mock-restaurant.com'
    };

    // Simulate tech detection (for mock mode)
    const tech: TechStack = {
      websitePlatform: 'WordPress',
      onlineOrdering: Math.random() > 0.6 ? ['ChowNow'] : [],
      reservations: Math.random() > 0.7 ? ['OpenTable'] : [],
      delivery: Math.random() > 0.2 ? ['DoorDash', 'UberEats'] : [],
      loyaltyOrCRM: [],
      pos: Math.random() > 0.5 ? ['Toast'] : [],
      otherScripts: ['Google Analytics 4'],
      confidence: 50,
      hasFirstPartyOrdering: Math.random() > 0.8
    };

    const fit = calculateFitScore(placeBase, tech, isIndie);

    // Apply Client-Side Tech Filters from Spec
    if (filters.requireNoFirstPartyOrdering && tech.hasFirstPartyOrdering) continue;
    if (filters.requireThirdPartyDelivery && tech.delivery.length === 0) continue;

    places.push({ ...placeBase, techStack: tech, fit });
  }

  const count = Math.max(baseCount, places.length);
  const sortedPlaces = places.sort((a, b) => b.fit.score - a.fit.score);
  const highFitCount = sortedPlaces.filter(p => p.fit.score >= 80).length;
  const avgScore = Math.floor(sortedPlaces.reduce((acc, p) => acc + p.fit.score, 0) / (sortedPlaces.length || 1));

  return {
    insightType,
    totalCount: count,
    breakdownByType: breakdown,
    places: insightType === InsightType.PLACES ? sortedPlaces : undefined,
    fitStats: { highFitCount, avgScore: avgScore || 65 }
  };
}

// --- MAIN AGENT FUNCTION ---

export const searchPlacesAggregate = async (
  area: SearchArea,
  filters: SearchFilters,
  insightType: InsightType

  const errorText = await response.text();
throw new Error(`Places API Error: ${response.status} ${errorText}`);
}

const data = await response.json();
const result = data.insightResults?.[0];

if (!result) return { insightType, totalCount: 0, breakdownByType: {} };

// 3. Process Counts
const count = result.count || 0;
const breakdown: Record<string, number> = {};
if (count > 0) {
  const types = body.filter.typeFilter.includedTypes;
  types.forEach((t: string) => breakdown[t] = Math.floor(count / types.length));
}

if (insightType === InsightType.COUNT) {
  return {
    insightType,
    totalCount: count,
    breakdownByType: breakdown,
    fitStats: { highFitCount: Math.floor(count * 0.25), avgScore: 0 }
  };
}

// 4. Process Places (The "Crawling" Phase)
let resourceNames = result.places?.map((p: any) => p.name) || [];

// Apply agent limit
if (resourceNames.length > AGENT_CONFIG.maxPlacesForScan) {
  resourceNames = resourceNames.slice(0, AGENT_CONFIG.maxPlacesForScan);
}

console.log(`ðŸ” Fetching details for ${resourceNames.length} restaurants...`);

// Parallel Fetch Details
const detailPromises = resourceNames.map((name: string) => fetchPlaceDetails(name.split('/')[1]));
const details = await Promise.all(detailPromises);
const validDetails = details.filter(p => p !== null) as Omit<PlaceResult, 'techStack' | 'fit'>[];

console.log(`âœ… Got details for ${validDetails.length} restaurants`);
console.log(`ðŸ•·ï¸  Starting tech stack detection (real web crawling)...`);

// 5. Apply Agent Intelligence (Independence, Tech Scan, Scoring)
const enrichedPlaces = await Promise.all(validDetails.map(async (p, index) => {
  const chainResult = detectChain(p.name, p.website);
  const isIndie = !chainResult.isChain;

  // Real tech detection (or fallback to mock if no website)
  let tech: TechStack;
  if (p.website) {
    try {
      tech = await detectTechStack(p.website);
      console.log(`  [${index + 1}/${validDetails.length}] ${p.name}: ${tech.websitePlatform}, ${tech.onlineOrdering.length} ordering, ${tech.delivery.length} delivery`);
    } catch (error) {
      console.warn(`  [${index + 1}/${validDetails.length}] ${p.name}: Tech detection failed, using fallback`);
      tech = {
        websitePlatform: 'Unknown',
        onlineOrdering: [],
        reservations: [],
        delivery: [],
        loyaltyOrCRM: [],
        pos: [],
        otherScripts: [],
        confidence: 10,
        hasFirstPartyOrdering: false
      };
    }
  } else {
    tech = {
      websitePlatform: 'Unknown',
      onlineOrdering: [],
      reservations: [],
      delivery: [],
      loyaltyOrCRM: [],
      pos: [],
      otherScripts: [],
      confidence: 10,
      hasFirstPartyOrdering: false
    };
  }

  const fit = calculateFitScore(p, tech, isIndie);
  return { ...p, techStack: tech, fit };
}));

console.log(`âœ… Tech detection complete!`);

// 6. Apply filters
const places = enrichedPlaces.filter(p => {
  // Agent Rules:
  if (filters.independentOnly && !p.fit.isIndependent) return false;
  if (p.fit.score === 0) return false; // Filter out disqualified
  if (filters.requireNoFirstPartyOrdering && p.techStack.hasFirstPartyOrdering) return false;
  if (filters.requireThirdPartyDelivery && p.techStack.delivery.length === 0) return false;
  return true;
}).sort((a, b) => b.fit.score - a.fit.score);

const highFitCount = places.filter(p => p.fit.score >= 80).length;
const avgScore = Math.floor(places.reduce((acc, p) => acc + p.fit.score, 0) / (places.length || 1));

console.log(`ðŸ“Š Results: ${places.length} qualified leads, ${highFitCount} high-fit (â‰¥80), avg score: ${avgScore}`);

return {
  insightType,
  totalCount: count || places.length,
  breakdownByType: breakdown,
  places: places,
  fitStats: { highFitCount, avgScore }
};

} catch (err) {
  console.error("API Call Failed - Switching to Simulation Mode", err);
  return runMockSearch(area, filters, insightType);
}
};

export const exportToCSV = (places: PlaceResult[]) => {
  const headers = [
    'Name',
    'Fit Score',
    'Fit Reason',
    'Independent',
    'Type',
    'Rating',
    'Reviews',
    'Price',
    'Address',
    'Website',
    'Website Platform',
    'POS',
    'Ordering (1P)',
    'Has 1P Ordering',
    'Delivery (3P)',
    'Reservations',
    'Loyalty/CRM',
    'Tech Confidence'
  ];

  const rows = places.map(p => [
    `"${p.name}"`,
    p.fit.score,
    `"${p.fit.reason}"`,
    p.fit.isIndependent ? 'Yes' : 'No',
    p.types[0],
    p.rating,
    p.userRatingCount,
    p.priceLevel || 'N/A',
    `"${p.address}"`,
    p.website || '',
    p.techStack.websitePlatform,
    `"${p.techStack.pos.join(', ')}"`,
    `"${p.techStack.onlineOrdering.join(', ')}"`,
    p.techStack.hasFirstPartyOrdering ? 'Yes' : 'No',
    `"${p.techStack.delivery.join(', ')}"`,
    `"${p.techStack.reservations.join(', ')}"`,
    `"${p.techStack.loyaltyOrCRM.join(', ')}"`,
    p.techStack.confidence
  ]);

  const csvContent = [headers.join(','), ...rows.map(r => r.join(','))].join('\n');
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);

  const link = document.createElement('a');
  link.setAttribute('href', url);
  link.setAttribute('download', `owner_prospects_${new Date().toISOString().split('T')[0]}.csv`);
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
};